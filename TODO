take any instance variables already in context and make them available to dataset blocks - this is for nested describes

add ability to clear the database (some tests wanted to guarantee a clear db)
  This is acheived with "dataset {}"

better handle STI
  people(:bobby)
  users(:bobby)
  family_members(:bobby)
  
clear database completely at beginning of session, only tables where data was created within a session??

clear all dumps on new run of tests
be sure we are capturing a dataset if it has already be captured before during a run
describe what happens when someone has a fixtures file - they get loaded after our datasets, thereby causing all the data in the table of the fixture file (like things.yml) to be deleted - the fixtures are then loaded
look into truncating database instead individual table deletes
allow configuration of dataset
  * permatable / global scope
re-evaluation location of some tests that depend on TestCase in non-test/unit tests

Dataset::Session.new
describe Something do
  dataset :a
  
  it 'should whatever'
  end
  
  describe More do
    dataset :b
    
    it 'should'
    end
  end
  
  describe Another do
    it 'should'
    end
  end
  
end

Dataset::Session.new
describe Something do
  dataset :a
  
  it 'should whatever'
  end
  
  describe More do
    dataset :b
    
    it 'should'
    end
  end
  
  describe Another do
    it 'should'
    end
  end
  
end


            Something(:a)
            
      More(:a,:b)       Another(:a)
      
      
      
Something  {:a}         (:a).load
More       {:a,:b}      (:b).load
Another    {:a}         (:b).unload  (restore :a)

This can be confusing. Refer to documentation of 'superset' on wikipedia
{:a}.superset?({:a,:b})

Something.superclass?(More)


definition of test classes where dataset usage is declared
running the tests, at which point we must extend the instances to have the data reading methods, creation methods
  during the run, the test methods should have access to the data that was created